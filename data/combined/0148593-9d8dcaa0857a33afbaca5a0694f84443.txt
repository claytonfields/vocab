What has been open sourced exactly?

The multiplayer feature can be split into a lower and higher layer. The lower one is the transport layer, mostly residing in the NetworkTransport class. This layer exists inside the Unity engine and is written in C++. Its main purpose is to provide a thin layer above socket access and we optimized it for performance. Above this, we have the high level API, which is written in C# and exists in a modular extension DLL. This extension DLL has been open sourced and you can modify/extend it and replace the one shipped with Unity. It’s released under the MIT/X11 license, which means you can use it as you like and there are no restrictions or requirements for contributing back any changes.

Two levels of abstraction.

The manual has a good overview for what you can do with the high level API. There are many classes inside the extension DLL and you could consider this split into two layers as well. Using the NetworkClient and NetworkServer classes, you could set up connectivity manually or use the NetworkManager or NetworkLobbyManager for even higher level access. You can add these managers to a game object for immediate connectivity options with another built-in HUD component. You can also extend them to perform custom behaviours. It’s designed to be client/server based and server authoritative (with a few client authority exceptions you could use). These classes are a good reference for how you could use the transport level yourself, to implement your own custom high level API. Even if you don’t intend to change anything, I can recommend you take a look at these to learn more about how the high level works.

A few things to consider.

Three Visual Studio project files come with the source: one for runtime, another for editor and finally the editor-runtime. The last one is for the runtime version, which runs when in PlayMode in the editor. The update method here is pumped from the engine itself so you need to have the NetworkIdentity.UNetUpdate() function around or nothing will happen when running. We have a code generation step which runs every time the user assembly is compiled in the editor. This generator is called the UNetWeaver and we’re considering open sourcing that too. It parses the NetworkBehaviours and generates serialization code, Command/ClientRPC handlers, lookup tables and so on. The names of these things (SyncVar, Command, etc) need to stay the same for these things to continue functioning.

Get the open source repository on Bitbucket.